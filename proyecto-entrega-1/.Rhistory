---
title: "Tarea 1"
subtitle: "Redes Sociales y Económicas"
author: "Jordi Vanrell, Daniel Ramos & Sergi Fornés"
output:
pdf_document: default
html_document: default
---
```{r global_options, include=FALSE}
knitr::opts_chunk$set(fig.width=8, fig.height=8, fig.align="center", echo=TRUE, warning=FALSE, message=FALSE)
library(knitr)
library(igraph)
```
**1)** The file **facebook_sample_anon.txt** is a data table containing the list of edges of an anonymized sample of the Facebook friendship network. Download it on your computer,  upload it to R as a dataframe, and define an undirected graph with this list of edges.
Leemos el archivo con los datos y lo metemos en un dataframe.
```{r}
data <- read.table("./data/facebook_sample_anon.txt")
head(data)
```
Observamos que en el data frame tenemos las aristas del grafo.
Creamos el grafo.
```{r}
gf <- graph_from_data_frame(d=data, directed = F)
```
***
*a)* Is it connected? If it is not, replace it by its largest connected component.
La función `is.connected` comprueba que el grafo es conexo.
```{r}
is.connected(gf)
```
Observamos que es cierto.
***
*b)* Compute the edge density.
```{r}
edge_density(gf, loops=F)
choose(vcount(gf),2)
ecount(gf)/choose(vcount(gf),2)
mean_distance(gf, directed = F)
dmt <- get_diameter(gf, directed = F)
dmt
# Creamos el atributo degree para cada nodo
V(gf)$degree = degree(gf)
# Creamos un subgrafo con el diámetro del grafo original
gf_dmt <- induced_subgraph(gf, dmt)
# Cambiamos el atributo del tamaño de cada nodo en función de su grado en el grafo original
V(gf_dmt)$size = 2*sqrt(V(gf_dmt)$degree)
# Lo imprimimos
plot(gf_dmt,
vertex.color = "grey80",
edge.color = "black",
edge.width = 1,
vertex.label.color = "black",
vertex.label.font = 2,
main = "Diámetro del grafo")
shrt_pth <- shortest_paths(gf,
from = V(gf)[name=="1000"],
to  = V(gf)[name=="2000"])$vpath
shrt_pth
4000^4
4^$
4^4
# Obtenemos los nodos con 1 vecino (los de grado 1)
alone <- V(gf)[V(gf)$degree == 1]
# Obtenemos la lista de nodos vecinos de los nodos de grado 1
vecinos <- adjacent_vertices(gf, alone)
# Convertimos la lista en un vector con las posiciones de los vecinos
pos_v <- unlist(vecinos, use.names=FALSE)
# Usamos la posición para encontrar los vecinos
list_v <- V(gf)[pos_v]
# Quitamos nodos repetidos de la lista
list_v_u <- unique(list_v)
list_v_u
pos_v
unique(pos_v)
V(gf)[unique(pos_v)]
