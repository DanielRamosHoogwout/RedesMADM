---
title: "Entrega 1"
author: "Jordi Vanrell, Daniel Ramos & Sergi Fornés"
output:
  pdf_document: default
  html_document: default
---

```{r global_options, include=FALSE}
knitr::opts_chunk$set(fig.width=8, fig.height=8, fig.align="center", echo=TRUE, warning=FALSE, message=FALSE)
library(knitr)
library(igraph)
```


**1)** The file **facebook_sample_anon.txt** is a data table containing the list of edges of an anonymized sample of the Facebook friendship network. Download it on your computer,  upload it to R as a dataframe, and define an undirected graph with this list of edges.

Leemos el archivo con los datos y lo metemos en un dataframe.

```{r}
data <- read.table("facebook_sample_anon.txt")
head(data)
```

Creamos el grafo.

```{r}
gf <- graph_from_data_frame(d=data, directed = F)
```


*a)* Is it connected? If it is not, replace it by its largest connected component.

La función `is.connected` comprueba que el grafo es conexo.

```{r}
is.connected(gf)
```

Observamos que es cierto.

*b)* Compute the edge density.

```{r}
edge_density(gf, loops=F)
```

La densidad del grafo es de `r round(edge_density(gf, loops=F), 3)`. Esto significa que el `r round(edge_density(gf, loops=F)*100, 1)`% de las aristas posibles están definidas.

*c)* What is the mean distance among the subjects?

```{r}
mean_distance(gf, directed = F)
```

La media de la distancia más corta entre todos los pares de nodos posibles es `r round(mean_distance(gf, directed = F), 3)`.

*d)* Calculate the list of vertices in a diameter of the graph. Plot only this path with the size of the node proportional to the degree of the node.

Calculamos el diámetro.

```{r}
dmt <- get_diameter(gf, directed = F)
dmt
```

Lo dibujamos. FALTA ACABAR!FALTA ACABAR!FALTA ACABAR!

```{r, eval = F, echo=F}
plot(as.grapf(dmt))
g1 <- graph( edges=c(687,  686,  698,  3437, 567,  414,  594,  3980, 3981), n=3, directed=F )
ecol[E(gf, path=dmt)]
ecol <- rep("gray80", ecount(gf))
plot(gf, vertex.color="grey", edge.color=ecol, edge.arrow.mode=0)
vcol <- rep("gray40", vcount(gf))
vcol[dmt] <- "gold"
ecol <- rep("gray80", ecount(gf))
ecol[E(gf, path=dmt)] <- "orange" 
# E(net, path=diam) finds edges along a path, here 'diam'
plot(gf, vertex.color=vcol, edge.color=ecol, edge.arrow.mode=0, vertex.)






graph( edges=as.vector(dmt), n=3, directed=F )
```


*e)* Calculate the shortest path from the vertex named "1000" to the vertex named "2000" in the original file.

```{r}
shortest_paths(gf,
               from = V(gf)[name=="1000"],
               to  = V(gf)[name=="2000"])$vpath
```

*f)* Calculate a clique of 5 friends, if there is one. FALTA ACABAR!FALTA ACABAR!FALTA ACABAR!FALTA ACABAR!

```{r}
#sapply(cliques(gf), length)
```


*h)* Calculate the list of names of verteces that are the neigbours of verteces of degree one and that are not of degree one.

```{r}
# Ponemos el atributo degree a cada nodo
V(gf)$degree = degree(gf)

# Obtenemos los nodos con 1 vecino
alone <- V(gf)[V(gf)$degree == 1]

# Obtenemos la lista de nodos vecinos de los nodos de grado 1
vecinos <- adjacent_vertices(gf, alone)
```
